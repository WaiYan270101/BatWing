#include <DynamixelShield.h>

#if defined(ARDUINO_AVR_UNO) || defined(ARDUINO_AVR_MEGA2560)
  #include <SoftwareSerial.h>
  SoftwareSerial soft_serial(7, 8); // DYNAMIXELShield UART RX/TX
  #define DEBUG_SERIAL soft_serial
#elif defined(ARDUINO_SAM_DUE) || defined(ARDUINO_SAM_ZERO)
  #define DEBUG_SERIAL SerialUSB    
#else
  #define DEBUG_SERIAL Serial
#endif

const uint8_t DXL_ID = 1;
const float DXL_PROTOCOL_VERSION = 2.0;

DynamixelShield dxl;

//This namespace is required to use Control table item names
using namespace ControlTableItem;

// Kinematics of the sinusoidal motion
// Currently, the downstroke ratio is 0.5
float centre_deg = 90;
float amplitude_deg = 45;
float frequency_Hz = 5;

// arrays to record position values
float posArray1[100];
int size1 = 0;

float posArray2[100];
int size2 = 0;

void setup() {
  
  // For Uno, Nano, Mini, and Mega, use UART port of DYNAMIXEL Shield to debug.
  DEBUG_SERIAL.begin(115200);

  // Set Port baudrate to 57600bps. This has to match with DYNAMIXEL baudrate.
  dxl.begin(57600);
  // Set Port Protocol Version. This has to match with DYNAMIXEL protocol version.
  dxl.setPortProtocolVersion(DXL_PROTOCOL_VERSION);
  // Get DYNAMIXEL information
  dxl.ping(DXL_ID);

  // Turn off torque when configuring items in EEPROM area
  dxl.torqueOff(DXL_ID);
  dxl.setOperatingMode(DXL_ID, OP_POSITION);

  dxl.writeControlTableItem(RETURN_DELAY_TIME, DXL_ID, 0);

  // sinusoidal motion is approximated by a position profile generated by a trapezoidal velocity profile 
  // a position profile is generated between each pair of adjacent positive and negative peaks of the sine wave 

  // configure Drive Mode to enable time based velocity profile generation
  dxl.writeControlTableItem(DRIVE_MODE, DXL_ID, 4);
  // set Profile Acceleration, which for time based profile, defines the acceleration time
  float period_ms = 1/frequency_Hz * 1000;
  float posPeak2negPeak_ms = period_ms/2;
  // for trapezoidal velocity profile, acceleration time is chosen to be approximately one third of the interval between adjacent positive and negative peaks 
  dxl.writeControlTableItem(PROFILE_ACCELERATION, DXL_ID, static_cast<int32_t>(posPeak2negPeak_ms/3));
  // set Profile Velocity, which for time based profile, defines the time taken to reach the final position
  dxl.writeControlTableItem(PROFILE_VELOCITY, DXL_ID, static_cast<int32_t>(posPeak2negPeak_ms));

  dxl.writeControlTableItem(VELOCITY_LIMIT, DXL_ID, 2000);
  dxl.torqueOn(DXL_ID);

  // Confirm if the settings have been set properly
  DEBUG_SERIAL.println("SETTINGS");

  DEBUG_SERIAL.print("ReturnDelayTime : ");
  DEBUG_SERIAL.println(dxl.readControlTableItem(RETURN_DELAY_TIME, DXL_ID));

  DEBUG_SERIAL.print("DriveMode : ");
  DEBUG_SERIAL.println(dxl.readControlTableItem(DRIVE_MODE, DXL_ID));

  DEBUG_SERIAL.print("ProfileAcceleration : ");
  DEBUG_SERIAL.println(dxl.readControlTableItem(PROFILE_ACCELERATION, DXL_ID));

  DEBUG_SERIAL.print("ProfileVelocity : ");
  DEBUG_SERIAL.println(dxl.readControlTableItem(PROFILE_VELOCITY, DXL_ID));

  DEBUG_SERIAL.print("VelocityLimit : ");
  DEBUG_SERIAL.println(dxl.readControlTableItem(VELOCITY_LIMIT, DXL_ID));

  // start from the negative peak position
  dxl.setGoalPosition(DXL_ID, centre_deg-amplitude_deg, UNIT_DEGREE);

  // wait while the servo is moving
  while(dxl.readControlTableItem(MOVING, DXL_ID))
  {
    // read and store the position values every 5 ms
    posArray1[size1++] = dxl.getPresentPosition(DXL_ID, UNIT_DEGREE);
    delay(5);
  }
  // delay(10);
  // DEBUG_SERIAL.println(dxl.readControlTableItem(MOVING_STATUS, DXL_ID));

  // check current position 
  float negPeak = dxl.getPresentPosition(DXL_ID, UNIT_DEGREE);
  // record RealTimeTick
  int32_t negTick = dxl.readControlTableItem(REALTIME_TICK, DXL_ID);

  // delay(3000);

  // move to positive peak
  dxl.setGoalPosition(DXL_ID, centre_deg + amplitude_deg, UNIT_DEGREE);
  // delay(5);
  
  // wait while the servo is moving
  while(dxl.readControlTableItem(MOVING, DXL_ID))
  {
    posArray2[size2++] = dxl.getPresentPosition(DXL_ID, UNIT_DEGREE);
    delay(5);
  }
  // DEBUG_SERIAL.println(dxl.readControlTableItem(MOVING_STATUS, DXL_ID));

  // record RealTimeTick
  int32_t posTick = dxl.readControlTableItem(REALTIME_TICK, DXL_ID);
  // check current position
  float posPeak = dxl.getPresentPosition(DXL_ID, UNIT_DEGREE);

  // print all the recorded values to DEBUG_SERIAL
  DEBUG_SERIAL.println("Moving to PositivePeak : ");
  for(int i=0; i<size1; i++)
  {
    DEBUG_SERIAL.println(posArray1[i]);
  }

  DEBUG_SERIAL.print("NegativePeak : ");
  DEBUG_SERIAL.println(negPeak);

  DEBUG_SERIAL.print("NegativeTick : ");
  DEBUG_SERIAL.println(negTick);

  DEBUG_SERIAL.println("Moving to NegativePeak : ");
  for(int i=0; i<size2; i++)
  {
    DEBUG_SERIAL.println(posArray2[i]);
  }

  DEBUG_SERIAL.print("PositivePeak : ");
  DEBUG_SERIAL.println(posPeak);

  DEBUG_SERIAL.print("PositiveTick : ");
  DEBUG_SERIAL.println(posTick);

}

void loop() {
  
  // move to positive peak
  dxl.setGoalPosition(DXL_ID, centre_deg + amplitude_deg, UNIT_DEGREE);
  // wait while the servo is moving
  delay(30);
  while(dxl.readControlTableItem(MOVING, DXL_ID))
  {
    // DEBUG_SERIAL.println(dxl.readControlTableItem(MOVING_STATUS, DXL_ID));
    // delay(10);
  }
  // DEBUG_SERIAL.println(dxl.readControlTableItem(MOVING_STATUS, DXL_ID));

  // DEBUG_SERIAL.print("Present Position(degree) : ");
  // DEBUG_SERIAL.println(dxl.readControlTableItem(REALTIME_TICK, DXL_ID));
  // DEBUG_SERIAL.println(dxl.getPresentPosition(DXL_ID, UNIT_DEGREE));

  // move to negative peak
  dxl.setGoalPosition(DXL_ID, centre_deg - amplitude_deg, UNIT_DEGREE);
  // wait while the servo is moving
  delay(30);
  while(dxl.readControlTableItem(MOVING, DXL_ID));
  // DEBUG_SERIAL.print("Present Position(degree) : ");
  // DEBUG_SERIAL.println(dxl.readControlTableItem(REALTIME_TICK, DXL_ID));
  // DEBUG_SERIAL.println(dxl.getPresentPosition(DXL_ID, UNIT_DEGREE));
  
}